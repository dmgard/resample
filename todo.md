- DOING Over-under resampler
  - DONE use Farey sequence online binary search to find nearest fractional approximations within a limit
    - OBSOLETE increasing approximate numerator and denominator both by 1 nudges the resample ratio down by a perhaps minimal amount. Decreasing both by 1 would have the opposite effect. Maybe scale to a floored 512 numerator ratio and then nudge low to find the phasecount(s) <=512 such that the resampler discrepancy is minimized
      - If the initial resample ratio approximation is always lower than the target, decrementing both numerator and denominator by 1 will always increase the sample ratio. At some small number of such steps the threshold between under and over will be crossed, providing near integer approximations
      - Consider implicit binary search of generated Farey sequence
  - TODO also need to accept floating point sample rates, as that's what real devices actually return
  - TODO can probably test this resampler audibly before even building the SIMD version. It already runs at 100x real time in the scalar mode.
  - DONE Extract consts/coefs into reusable, shared bundle, embedded in resampler
  - DONE? Keep count of deviation between approximate and ideal resampling
  - DONE On phase-wrap, swap to alternate coef/const bundle 
- Multichannel
- SIMD
  - Fixed-register-length AVX/512 resampler kernels for all multiples of register counts
  - SSE+AVX/512 version of the scalar load-accum-store resampler for arbitrary filter lengths
    - Broadcast sample, multiply by coefs and do unaligned load, add, store
    - Pad filters to register length
    - Might even have enough time to calculate sinc coefficients online using approximations due to how memory-bound the operation would be
  - Can basically adapt current resampler by zero-padding coefficient phases by register len on either end and adjusting tapcount offset separately for loads
  - Eventually add SIMD coefficient generation
  - Need to consider extending length of output slice and copying+wrapping outIdx to avoid per-register index wrapping in assembly
    - Basically, pad output with enough room to always write partial accumulated samples past the midpoint. Once output is writing completely past the midpoint, copy midpoint:output+taps samples back to the start of output and wrap/update relevant indices
- API
  - Compute taps needed for desired -3db point, ripple, and rejection
- Tests
- Readme
  - Basically brings inner-outer convolution loop vectorization optimization to a multirate polyphase resampler