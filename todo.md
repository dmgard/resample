- COMPILER/ASSEMBLER BUG?
  - Three-argument SHRQ `SHRQ $+36, R8, R9` encodes as `RORQ` somehow?
- MVP
  - DONE combine SIMD into regular resampler, deprecate/private online resampler
  - TODO single method "resample all"
  - TODO SIMD sinc coefficient generation
  - TODO coefficient reset alignment
    - Limit input read to output buffer space
    - While `len(in) * phases + s.coefsIdx > len(s.coefs)`... do something to limit input samples even though `s.coefsIdx` is premultiplied by tapcount...
  - TODO F64
  - TODO general conversions?
    - Small conversion buffer for incoming+outgoing data, ASM convert+quantize routines
  - TODO multichannel
    - Optional channel count parameter, create N input/output buffers, accept N input slices, process to each buffer
    - Accept N output slices to `Read`, copy and wrap each
  - TODO quality presets, auto-quality based on filter params
  - TODO fallback "slow" SSE/AVX/512 paths for unlimited length impulses
  - TODO quality tests
- BUGS SIMD
	- DONE-ISH sub-register phase coefficient filter alignment
    - ISSUE Initial coefficient read should be +vecLen but wraps to zero
    - BUG periodic errors in output
  - FIXED-ISH sub-register offset calculation needs improvements and/or bounds checks
    - Offset coefIdx in assembly by one vector length before and after each resample loop
  - TODO coef wrapping needs to reset to zero even during SIMD
		- Causing segfaults and would be expected to when switching between over/under ratios between phases
  - TODO always-odd resample taps for SIMD
  - DONE? need to quantize initial output vector reload to nearest vector bounds
    - dovetails with only recalculating offsets at the end of the loop
    - TODO initial load also needs to wrap output buffer
  - NO? final output slice index doesn't update until loop entered, leading it to potentially (?) lag behind on final update?
  - FIXED? Anyway, regardless of the cause, there's definitely something wrong there. Seems to skip a vector or something, shifting all output by one register of samples?
    - Output index seems to jump forward by a register length every two sets of input quanta, on both size 4 and 8 quanta with 16 taps filter
  - FIXED due to 3-arg SHRQ becoming RORQ somehow: Intermediate registers seem to save and advance too often (every input sample) at very least at very close sample rates
  - FIXED? Final register save might advance by a full register in memory inappropriately/indiscriminately
- TODO codify taps as input samples or output samples: currently, actual taps scale with resample ratio
- TEST simd:
  - Build scalar clone of SIMD logic using SIMD primitives, conditional gotos and the like
  - Inspect SIMD output with trivial/known impulses, like an impulse train filter applied to a dirac delta and itself and vice versa
- DOING Over-under resampler
  - DONE use Farey sequence online binary search to find nearest fractional approximations within a limit
    - OBSOLETE increasing approximate numerator and denominator both by 1 nudges the resample ratio down by a perhaps minimal amount. Decreasing both by 1 would have the opposite effect. Maybe scale to a floored 512 numerator ratio and then nudge low to find the phasecount(s) <=512 such that the resampler discrepancy is minimized
      - If the initial resample ratio approximation is always lower than the target, decrementing both numerator and denominator by 1 will always increase the sample ratio. At some small number of such steps the threshold between under and over will be crossed, providing near integer approximations
      - Consider implicit binary search of generated Farey sequence
  - DONE also need to accept floating point sample rates, as that's what real devices actually return
  - TODO can probably test this resampler audibly before even building the SIMD version. It already runs at 100x real time in the scalar mode.
  - DONE Extract consts/coefs into reusable, shared bundle, embedded in resampler
  - DONE? Keep count of deviation between approximate and ideal resampling
  - DONE On phase-wrap, swap to alternate coef/const bundle 
- Multichannel
- SIMD
  - Fixed-register-length AVX/512 resampler kernels for all multiples of register counts
  - SSE+AVX/512 version of the scalar load-accum-store resampler for arbitrary filter lengths
    - Broadcast sample, multiply by coefs and do unaligned load, add, store
    - Pad filters to register length
    - Might even have enough time to calculate sinc coefficients online using approximations due to how memory-bound the operation would be
  - Can basically adapt current resampler by zero-padding coefficient phases by register len on either end and adjusting tapcount offset separately for loads
  - Eventually add SIMD coefficient generation
  - Need to consider extending length of output slice and copying+wrapping outIdx to avoid per-register index wrapping in assembly
    - Basically, pad output with enough room to always write partial accumulated samples past the midpoint. Once output is writing completely past the midpoint, copy midpoint:output+taps samples back to the start of output and wrap/update relevant indices
- API
  - Compute taps needed for desired -3db point, ripple, and rejection
- Tests
- Readme
  - Basically brings inner-outer convolution loop vectorization optimization to a multirate polyphase resampler